
import bpy
import mathutils
import numpy as np

# Coordinate transformation function between polar and cartesian
def cartesianToPolarCoords(XYZ, useLonLat=True):
    X, Y, Z = XYZ[:, 0], XYZ[:, 1], XYZ[:, 2]
    R = (X**2 + Y**2 + Z**2)**0.5
    theta = np.arctan2(Y, X)
    phi = np.arccos(Z / R)
    
    #Return results either in spherical polar or leave it in radians
    if useLonLat == True:
        theta, phi = np.degrees(theta), np.degrees(phi)
        lon, lat = theta - 180, 90 - phi
        lon[lon < -180] = lon[lon < -180] + 360
        return R, lon, lat
    else:
        return R, theta, phi

# Reads data from any XY file
def readXYfile(fileDir):
    data = []
    file = open(fileDir, "r")
    for line in file:
        if line[0] == '>':
            continue
        data.append([float(n) for n in line.split()])
    data = np.array(data)
    file.close()
    return data

# Load velocity data from .XY files generated by GPlates
def readVelocityLonLat(fileDir, lonLatScaling=1e-1, velocityScaling=1e-1):
    xyData = readXYfile(fileDir)
    posLon = xyData[:, 0] * lonLatScaling
    posLat = xyData[:, 1] * lonLatScaling
    velLon = xyData[:, 3] * lonLatScaling * velocityScaling
    velLat = -xyData[:, 2] * lonLatScaling * velocityScaling
    zeros = np.zeros(posLon.shape[0])
    velocityPositions = np.stack((posLon, posLat, zeros), axis=1)
    velocities = np.stack((velLon, velLat, zeros), axis=1)
    return velocityPositions, velocities

# Load velocity data from .XY files generated by GPlates
def readVelocityXY(fileDir, lonLatScaling=1e-1, velocityScaling=1e-2):
    xyData = readXYfile(fileDir)
    posLon = xyData[:, 0] * lonLatScaling
    posLat = xyData[:, 1] * lonLatScaling
    velX = xyData[:, 2] * velocityScaling
    velY = xyData[:, 3] * velocityScaling
    velZ = xyData[:, 4] * velocityScaling
    velXYZ = np.stack((velX, velY, velZ), axis=1)

    # Remove zero velocities
    speeds = np.linalg.norm(velXYZ, axis=1)
    whereNotZeroVel = np.argwhere(speeds!=0)[:, 0]
    velXYZ = velXYZ[whereNotZeroVel]
    _, velLon, velLat = cartesianToPolarCoords(velXYZ)

    # Create velocity vectors
    zeros = np.zeros(posLon.shape[0])
    velocityPositions = np.stack((posLon, posLat, zeros), axis=1)
    velocities = np.stack((velLon, velLat, zeros[whereNotZeroVel]), axis=1) * lonLatScaling * velocityScaling
    return velocityPositions[whereNotZeroVel], velocities


# Takes the direction of a vector, and return the euler rotations required by blender
def directionToEulerRotations(direction, N=np.array([0, 0, 1])):
    quatAxis = np.cross(N, direction)
    quatAngle = np.arccos(np.dot(N, direction))
    rotQuat =  mathutils.Quaternion(quatAxis, quatAngle)
    return rotQuat.to_euler()

# Change this to your velocities directory
#fileDirFormat = 'D:/UniSydney/Research/20220726Tibet/BlenderFlatEarth/GPlatesData/20x20VelocitiesXYZ/velocity_{}.00Ma.xy'
fileDirFormat = 'D:/UniSydney/Research/20220726Tibet/BlenderFlatEarth/GPlatesData/28x32VelocitiesLatLon/velocity_{}.00Ma.xy'

# Timestep of velocity data
time = 79

# Parameters for the Warp Modifier
warpStrength = 1 / 7.2
warpRadius = 0.8
warpFalloffType = 'SMOOTH'

# Scaling of coordinates (these need to be the same as those used for generating NPZ files)
lonLatScaling = 1e-1
elevsScaling = 1e-5

# Read velocity data
fileDir = fileDirFormat.format(time)
#velocityPositionFrom, velocity = readVelocityXY(fileDir, lonLatScaling=lonLatScaling)
velocityPositionFrom, velocity = readVelocityLonLat(fileDir, lonLatScaling=lonLatScaling)
velocityPositionTo = velocityPositionFrom + velocity

# Filter out any zero velocities from data
speeds = np.linalg.norm(velocity, axis=1)
whereNotZeroVel = np.argwhere(speeds!=0)[:, 0]
velocity = velocity[whereNotZeroVel]
velocityPositionFrom = velocityPositionFrom[whereNotZeroVel]
velocityPositionTo = velocityPositionTo[whereNotZeroVel]

# Get a reference to our current active object (our landscape)
# So we can use it later
topoMesh = bpy.context.active_object

# Loop through velocities and add them as arrows
for i, vel in enumerate(velocity):
    rotation = directionToEulerRotations(vel)

    # Create the "From" arrow for our warp modifier
    bpy.ops.object.empty_add(
        type = 'SINGLE_ARROW',
        location = velocityPositionFrom[i],
        rotation = rotation)
    arrowFrom = bpy.context.active_object

    # Create the "To" arrow for our warp modifier
    bpy.ops.object.empty_add(
        type = 'SINGLE_ARROW',
        location = velocityPositionTo[i],
        rotation = rotation)
    arrowTo = bpy.context.active_object

    # Create new warp modifier, change relevant parameters and apply the modifier
    warpModifier = topoMesh.modifiers.new('SomeRandomName', 'WARP')
    warpModifier.object_from = arrowFrom
    warpModifier.object_to = arrowTo
    warpModifier.strength = warpStrength
    warpModifier.falloff_radius = warpRadius
    warpModifier.falloff_type = warpFalloffType
    bpy.context.view_layer.objects.active = topoMesh
    bpy.ops.object.modifier_apply(modifier=warpModifier.name)

    # Delete current arrows
    topoMesh.select_set(False)
    arrowFrom.select_set(True)
    arrowTo.select_set(True)
    bpy.ops.object.delete()

bpy.context.view_layer.objects.active = topoMesh